#### Решение на bash:

* Общее количество запросов

Производит подсчет строк в access.log

cat access.log | wc -l

* Общее количество запросов по типу

Выделяет название типа запроса из каждой строки, после производит подсчет уникальных типов запросов

cat access.log | awk -F'"' '{print $2}' | awk '{print $1}' | sort | uniq -c | sort -n | awk '{print $2,$1}'

* Топ 10 самых частых запросов

Выделяет location(url) из каждого запроса, после производит подсчет уникальных 
   
cat access.log | awk -F'"' '{print $2}' | awk '{print $2}' | sort | uniq -c | sort -n | tail

На случай если я неправильно понял задание и запросы должны быть различны не только по location(url), а по всему запросу в целом, то есть такой скрипт:

cat access.log | awk -F'"' '{print $2,$4}' | sort | uniq -c | sort -n | tail

* Топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой

Выделяются запросы, имеющие клиентскую ошибку, из них выбираются url, статус код, размер запроса и ip, они сортируются по размеру запроса (sort -nk 3, где 3 - расположение размера в строке)
    
cat access.log | awk -F'"' '/" 4../{print $1, $2, $3}' | awk '{print $(NF-3),$(NF-1),$(NF),$1}' | sort -nk 3 | tail -5

Аналогично предыдущему скрипту, если я допустил ошибку в задании, то добавляю этот скрипт с более полной информацией: 

cat access.log | awk -F'"' '/" 40./{print $1,$2,$3,$4}' | awk '{print $(NF-4),$(NF-3),$NF,$(NF-2),$(NF-1),$1}' | sort -nk 5 | tail -5
         
* Топ 5 пользователей по количеству запросов, которые завершились серверной (5ХХ) ошибкой

Выделяются запросы, имеющие серверную ошибку, из них выбираются ip адреса и подсчитывается количество уникальных, вывод сортируется

cat access.log | awk '/" 50./{print $1}' | uniq -c | sort -n | tail -5 | awk '{print $2,$1}'

#### Решение на Python:

Все скрипты находятся в исполняемом файле nginx_pars. При вызове с флагом --json результаты записываются в nginx_data.json. При вызове без флага вывод производится на экран.

#### Результаты

Результаты находятся в results.txt

#### Выводы

Скрипты на bash работают очень быстро и просты в написании, поэтому, по моему мнению, использование скриптов на python целесообразно при необходимости их запуска на ос без bash, ведь регулярные выражения на таких больших log - файлах отрабатывают очень долго. Время работы можно сократить (хотя с bash оно все равно не сравнится), если сделать одновременное формирование результатов для разных скриптов, однако я оставил независимые друг от друга функции, чтобы было легко убрать или добавить их.